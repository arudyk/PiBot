#!/usr/bin/env python2

import logging
import multiprocessing
from argparse import ArgumentParser
import socket, ssl

"""
Handles all incoming tcp connection to PiBot for controlling over a network,
supports multithreading and ssl.

@author Andriy Rudyk
@author Tim Sizemore
@version 10 November 2013
"""

def handle(conn, address, key, cert):
    """
    Handles a single connection.

    @param conn - Connection socket (welcome socket)
    @param address - Address of the connected socket
    @param key - key of the server (pricate key)
    @param cert - certificate of the server (private key)
    """
    logging.basicConfig(level=logging.DEBUG) # Use for debigging
    logger = logging.getLogger("process-%r" % (address,))
    try:
        logger.debug("Connected %r at %r", conn, address)
        while True:
            connstream = ssl.wrap_socket(conn,
                                        server_side=True,
                                        certfile=cert,
                                        keyfile=key,
                                        ssl_version=ssl.PROTOCOL_TLSv1)
            data = connstream.read()
            if data == "":
                logger.debug("Socket closed remotely")
                break
            logger.debug("Received data %r", data)
            #
            # TODO:
            #
            # 1.) Check if data contains server key.
            # 2.) If so, listen for actions.
            # 3.) Run appropriate pibot methods.
            serverKey = open(key, 'r').read()
            if data == serverKey:
                # authenticate
                conn.sendall(data)
            logger.debug("Sent data")
    except:
        logger.exception("Problem handling request")
    finally:
        logger.debug("Closing socket")
        conn.close()
 
class Server(object):
    """
    Represents a server welcoming socket that then forks of to the handler.
    """
    def __init__(self, hostname, port, key, cert):
        """
        Sets up the necessery variables for a single connection.
        """
        self.logger = logging.getLogger("server")
        self.hostname = hostname
        self.port = port
        self.key = key
        self.certificate = cert
 
    def start(self):
        """
        Listens for incoming connections.
        """
        self.logger.debug("listening")
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.bind((self.hostname, self.port))
        self.socket.listen(1)
 
        while True: # Listen forever
            conn, address = self.socket.accept()

            self.logger.debug("Got connection")
            process = multiprocessing.Process(target=handle, args=(conn, address, self.key, self.certificate))
            process.daemon = True
            process.start()
            self.logger.debug("Started process %r", process)
 
if __name__ == "__main__":
    """
    Main loop, entry to the application.
    """

    # Setup argument parsing
    argparse = ArgumentParser(description='A multithreaded tcp command server with ssl encryption.', epilog='Harness the power of the duck')
    
    argparse.add_argument('port', metavar='PORT', type=int,
        help='port number for server to listen on')
    argparse.add_argument('key', metavar='SSL_KEY', type=str,
        help='path to ssl key file generated by openssl')
    argparse.add_argument('certificate', metavar='SSL_CERT', type=str,
        help='path to ssl certificate file generated by openssl')

    args = argparse.parse_args()

    # Setup logging
    logging.basicConfig(level=logging.DEBUG)
    server = Server("0.0.0.0", args.port, args.key, args.certificate)
    
    try:
        logging.info("Listening")
        server.start()
    except:
        logging.exception("Unexpected exception")
    finally:
        logging.info("Shutting down")
        for process in multiprocessing.active_children():
            logging.info("Shutting down process %r", process)
            process.terminate()
            process.join()
    logging.info("All done")
